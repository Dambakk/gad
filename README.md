# A novel approach to graphical user interface development using automatic code generation from images

This is the Bachelor's thesis for Einar Johnsen and Christopher Dambakk, University of Agder, spring 2017. Graphical user interface (GUI) development is a time consuming process. This thesis shows that the foundation of a graphical user interface can be automatically generated based on an image. The automation of GUI development lets the user spend valuable time creating improved user interfaces and user experiences. The image is a representation of the graphical user interface and the same representation is converted to runnable source code targeting different platforms. The thesis results in a prototype consisting of multiple tools streamlining the process of developing graphical user interfaces.

**Authors:**

Einar Johnsen	

Christopher Dambakk

**Supervisor:**

[Morten Goodwin](http://www.mortengoodwin.net/)

**Contractor:**

[Agens AS](https://www.agens.no/)

**Tool usage documentation further down**

Table of contents
=============
- [Introduction](#introduction)
- [Primary goals](#primary-goals)
- [Secondary goals](#secondary-goals)
- [Tertiary goals](#tertiary-goals)
- [Tool usage documentation](#tool-usage-documentation)
	- [Tool dependencies](#dependencies)
	- [Image Parser tool documentation](#the-image-parser)
	- [HTML generator tool documentation](#the-html-generator)
	- [iOS generator tool documentation](#the-ios-generator)


Introduction
============

The main goal of this project is to create a series of tools streamlining the process of creating \glslink{GUI}{graphical user interfaces} (GUI) for different platforms. The tools should be able to read an image of a GUI and generate the corresponding, runnable source code. The image is an idealized representation of the user interface where the different graphical components are marked by rectangles. The color of these rectangles are mapped to predefined, platform-specific graphical elements. The info possible to extract from the image is stored in a structural manner to be as interchangeable as possible, as well as being applicable to other use cases. The result generated by the tools is a complete and runnable project. It is also possible to change an existing GUI and add new GUIs to existing projects in a non-destructive manner. 


The problem statement is defined by the contractor Agens. Agens is an app development company stationed in Grimstad and Oslo who has a major activity in app development and they see a room for improvement when it comes to the way GUIs are created. According to Agens, many user interfaces in mobile apps are essentially the same with only minor differences in use of graphical elements, but are nevertheless time consuming to develop. In addition, app development is already heavily characterized by automation with the use of templates. However, the GUIs created by templates must often be altered to be adapted to the users requirements. This project aims to give developers a new way of creating GUIs in a fast and easy way. 

Agens have defined a list of goals and requirements relevant to produce a complete project and other interesting tasks to solve. The requirements in section Primary goals are essential and should be complete to consider this project a success. 

### Primary goals

-   Create a simple, extendable definition for all common UI elements.

-   Create a command line interface (CLI) tool that reads png images and pairs any app design contained to a structured representation.

-   Create a CLI transpiler to a selected platform. (e.g. iOS, Android, HTML, etc).

-   Write documentation for tool usage.

-   Support different levels of output logging and offer reasonable error messages.


### Secondary goals

-   Create a tool that draws a representation of the semantic representation for the sake of manually being able to verify the structure that is being created.

-   Extend the solution to handle more than one target platform and as many UI elements as possible.

-   It should be possible to run the tool chain multiple times without destroying work that has been manually done. It should also be possible for the designer to update the drawings and add/change UI elements and add those to the project in a non destructive manner.

- Code that is generated should follow good naming conventions and avoid uninformative names, like label\_1 or textbox3 etc. This will require some sort of analysis or meta information solution.

### Tertiary goals

- Extend the image parser and transpilers to include application navigation flow.

- Extend the image parser to consider meta information. Examples of meta information could be contextual names (e.g. user name, phone number, etc) or composite or custom UI elements.

- Extend the tools to support user defined elements.

- Extend the transpiler to consider meta information such as API endpoints, namespaces and libraries.

- Recommend features and tools that can extend the tool chain.

- Extend the image parser to work directly on the designers sketch, without the designer marking the UI elements.

- Set the tool chain up as a private tap for use with the OS X package manager homebrew. 



Tool usage documentation
===============

## Dependencies


The tools use the following external libraries:

### Image Parser:
- argparse - https://docs.python.org/3/library/argparse.html
- json - https://docs.python.org/3/library/json.html
- PIL - https://pypi.python.org/pypi/PIL
- colorama - https://pypi.python.org/pypi/colorama
- configparser - https://docs.python.org/3/library/configparser.html
- collections - https://docs.python.org/3/library/collections.html
- time - https://docs.python.org/3/library/time.html
- itemgetter ?
- deepcopy ?


### HTML generation tool:
- argparse - https://docs.python.org/3/library/argparse.html
- json - https://docs.python.org/3/library/json.html
- configparser - https://docs.python.org/3/library/configparser.html
- collections - https://docs.python.org/3/library/collections.html
- BeautifulSoup ver 4 - https://pypi.python.org/pypi/beautifulsoup4
- pprint ?


### iOS generation tool:
- argparse - https://docs.python.org/3/library/argparse.html
- colorama - https://pypi.python.org/pypi/colorama
- configparser - https://docs.python.org/3/library/configparser.html
- collections - https://docs.python.org/3/library/collections.html
- json - https://docs.python.org/3/library/json.html
- GitPython - https://pypi.python.org/pypi/GitPython/
- re - https://docs.python.org/3/library/re.html Is this external or not?
- readline - https://docs.python.org/3/library/readline.html
- time - https://docs.python.org/3/library/time.html
- glob - https://docs.python.org/3/library/glob.html
- copy_tree distutils.dir_util - https://docs.python.org/3/library/distutils.html
- shutil - https://docs.python.org/3/library/shutil.html
- subprocess ?
- fileinput ?
- pprint ?



## The Image Parser

### The input image

The input image must be standardized for the parser to understand it. Follow these rules:

- Must be a png file.
- Anti aliasing must be turned off when designing the image.
- For a best possible result, match the image size with the size of the desired result.
- Colored rectangles represent the different graphical components. Each color represent a kind of component.

Image (4) is an example of how the input image might look like. 

![Example image](RealWorldExample2.1.png)  


## The HTML generator


## The iOS generator


### Running the generator:

To run the iOSGenerator open a console and enter the following:
`python3 PATH_TO_IOSGEN/iosgenerator.py PATH_TO_JSON PATH_TO_OUTPUT`
where
- `PATH_TO_IOSGEN` is the location of the iosgenerator on your computer.
- `PATH_TO_JSON` is the complete filepath to the JSON file containing the description of the view. This JSON file will typically be the output of the Image Parser-tool. E.g. `/home/username/documents/myFirstView.json`
- `PATH_TO_OUTPUT` is the path to desired place to put the created project or the path to the project to be updated. The last directory will be the folder containing the app and will be the name of the app. E.g. `/home/dev/apps/MyFirstApp` where MyFirstApp is the name of the app.

You can also add one or more of the following flags:
- `-v` for a more verbose output logging to the console.
- `-f` is the force flag to make the script continue even if it may cause unexpected behaviour and results. Without the flag, the program will stop and tell the user to add the flag if it encounter any problems.

The script will ask for input during runtime, such as enter a name for the view, select a view or commit changes using git.
For further help, use `--help` or `-h` when running the tool.